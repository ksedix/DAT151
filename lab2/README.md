Programming Language Technology (Chalmers DAT151 / GU DIT231)

Lab 2: Type checker and interpreter for C--
===========================================

# Summary

The objective of this lab is to write a type checker and an interpreter for the fragment "C--" of the C++ programming language introduced below.
The type checker should check the program reconstructing the types of all expressions and send it to the interpreter at success.
The interpreter should run the program and correctly perform all its input and output actions.
In case type checking fails, a type error should be reported.

Before the lab can be submitted, the program has to pass some tests, which are included in git repository for this lab.

The recommended implementation is via a BNF grammar processed by the BNF Converter ([BNFC](https://bnfc.digitalgrammars.com/)) tool.
The syntax tree created by the parser should then be processed further by a program using the skeleton generated by BNFC.

The fragment of C++ covered is smaller than in Lab 1, and does not really include any C++ specific features not available in C.
You can use the grammar [CMM.cf](./CMM.cf), also explained in the PLT book, Chapter 2.

The type checker and the interpreter code will be roughly 300-800 lines together, depending on the programming language used.

All BNFC supported languages can be used, but guidance is guaranteed only for Haskell and Java.

The type system and the interpreter are partially characterized by formal rules in the PLT book, chapters 4 and 5.

# Method

In the type checker, the recommended procedure is two passes:
1. build a global context mapping all function to their types, including the built-in functions;
2. type check the code by using this global and a local context for variables, producing type-annotated code.

Type-annotations are needed to insert coercions from `int` to `double` at the right places.

In the interpreter, do a similar thing:
1. build a global environment that provides for every function its parameters and type-annotated syntax tree;
   the built-in functions can be left out and treated separately in the rule for evaluating function calls;
2. interpret the program by evaluating the expression `main()`.

# The type checker

Besides the _global context_ (aka _signature_)for function types, the type checker maintains a _(local) context_ which maps _variables_ in scope to their type.
The context is organized as a stack of _context blocks_, each of which is a map from variables to types.
When a new variable `x` of type `t` is declared, the top-most context block is extended by an entry mapping `x` to `t`.
When a new statement block is entered, a new context block is pushed onto the stack.
It is popped again when the statement block closes.

## Types

Only the four built-in types
* `int`
* `double`
* `bool`
* `void`

are taken into account.
Every expression has one of these types.

### Subtyping

A value of type `int` can be implicitly coerced (cast) to a value of type `double`.
This means that whenever an expression of type `double` is expected, an expression of type `int` is also acceptable.

### Function types

Types of functions in the global context can be represented in any way that stores their argument and return types.
For instance, the function header
```cpp
int f (double x, bool b)
```
will create a global context entry (not actual code)
```
f â†¦ ([double, bool], int)
```
that maps the identifier `f` to a pair whose first component is the list of argument types and the second component is the return type.

## Programs

A program is a sequence of function definitions.

A program may also contain comments and preprocessor directives, which are just ignored by the parser (see below).

An interpretable program must have a function `main` of type `int` that takes no arguments.
It may or may not have a `return` statement.
```cpp
int main () {
  ...
}
```

## Definitions

A function definition has a type, a identifier, an argument list, and a body.
Example:
```cpp
int foo (double x, int y)
{
  return y + 9 ;
}
```
The language has four **built-in functions** dealing with input and output:
* `void printInt(int x)` writes an integer (in decimal notation) and a newline to standard output.
* `void printDouble(double x)` prints a floating-point number and a newline to standard output.
* `int readInt()` reads an integer from standard input.
* `double readDouble()` reads a floating-point number from standard input.

(These functions are implemented in file [prelude.cc](testsuite/prelude.cc).
You can `#include` it in a test case if you want run the test through a C compiler.)

**Typing rules**

The same function identifier may be used in at most one function definition.

All `return` statements in a function body must return an expression whose type is the return type of the function.

You do not need to check that there actually is a `return` statement.

**Bonus task:**
Do check that each non-`void` function (except `main`) returns, in the sense that every execution of the function code will reach a `return` statement.
In general, this is an undecidable question (cf. `if (goldbachConjectureHolds) return 42;`), so the check should be conservative.
E.g. `if (e) s1; else s2;` only reaches `return` when __both__ `s1` and `s2` reach `return` (even if `e` is obviously `true` or `false`).
(Cf. Java, which does check for `return`.)

## Argument lists, declarations, and function bodies

An argument list is a comma-separated list of argument declarations.
It is enclosed in parentheses `(` and `)`.

An argument declaration has a type and an identifier, for instance:
```cpp
int x
```
Notice that argument declarations with multiple variables (`int x, y`) are not included.
(In contrast, a declaration that occurs as a statement (as shown below), can have more than one variable.)

A function body is a list of statements enclosed in curly brackets `{` and `}`.

**Typing rules**.
An argument list may not declare the same variable more than once.
The type of a variable cannot be `void`.
I.e., the following definition has two errors in the argument list.
```cpp
int error (int x, void y, bool x) { ... }
```

## Statements

### Declaration

Variable declarations have one of the following formats:

- type and one or more variables:
  ```cpp
  int i ;
  double x, y, z ;
  ```

- type and a single initialized variable
  ```cpp
  int i = 6 ;
  ```

**Typing**.
The type cannot be `void`.
The initializing expression must have the declared type in the __extended__ context.
This means that a function like
```cpp
int foo () {
  int i = i ;
  return i ;
}
```
is well-typed.
(Of course, this is not a meaningful program, since the variable `i` is never initialized and thus has a undefined value.)

__Note:__ Due to subtyping, a `double` variable may also be initialized with an `int` expression.

### Expression as Statement

Any expression followed by a semicolon `;` can be used as a statement.

__Remark:__
While any expression is allowed, only expressions with some side effect actually make sense here.
A side effect could be an assignment or a call to a function that makes some input or output action.

### Return Statement

Statements returning an expression, for example:
```cpp
return i + 9 ;
```

**Typing**.
The type of the returned expression must be the same as (or a subtype of) the return type of the function in which it occurs.

### Block

Any list of statements (including empty list) between curly brackets.
For instance:
```cpp
{
  int i = 2 ;
  int j = 5 ;
  {
    int i = 3 ;  // shadows the previous variable i
    {
    }
    i = i + j ;  // the inner i becomes 8
  }
  i++ ;          // the outer i becomes 3
}
```

**Typing rules**.
A block introduces a new __scope__.
A variable may only be declared once in a scope, i.e., on the same block level.
The parameters of a function live in the same scope as the top-level block in the body.
For example, the following function contains both violations:
```cpp
int scope_violation (int x) {
  int x = 1 ;    // already in scope as parameter
  {
    int y = 2 ;
    int y ;      // already declared in this block
  }
  return x ;
}
```

### While Loop

While loops, with an expression in parentheses followed by a statement, for example:
```cpp
while (i < 10) ++i ;
```

**Typing**.
The expression must have type **bool**.
Regardless whether the statement is a block or not, it lives in a new scope.
For example, in
```cpp
while (i++ < 10) int i = 0 ;
```
the declaration `int i = 0` creates a **new** variable `i` rather than setting the value of the existing variable `i` to `0`.
Thus, it needs to behave just as:
```cpp
while (i++ < 10) { int i = 0 ; }
```

### Conditional

`if` with an expression in parentheses followed by a statement (the first branch), `else`, and another statement (the second branch).
Example:
```cpp
if (x > 0) return x ; else return y ;
```

**Typing**.
The expression must have type **bool**.
Similar as for `while`, the two branches of an `if` statement live in new scopes.

## Expressions

The following table gives the expression forms `e`, their precedence levels, and their associativity.
The associativity of operators is given as left, right, or none.
For binary operators, in general any of the three associativities is meaningful.
For pre- and post-fix operators, at most one of left or right associativity makes sense, and the alternative is non-associative.
As they are bracketed, the arguments in a function call `x(e,...,e)` can be expressions of any level.
Otherwise, some subexpressions have to be one precedence level above of the main expression to implement the required associativity.

*Remark*.
Precedence and associativity departs in some cases from the [C++ standard](https://en.cppreference.com/w/cpp/language/operator_precedence), further, in/decrement and assignment is restricted to identifiers `x`.

| level | expression forms             | assoc | explanation   | type                         |
|:-----:|:-----------------------------|:-----:|:--------------|:-----------------------------|
|   6   | literal                      | -     | literal       | literal type                 |
|   6   | identifier `x`               | -     | variable      | declared type                |
|   6   | `x(e,...,e)`                 | none  | function call | return type                  |
|   6   | `x++`, `x--`                 | none  | in/decrement  | operand type (int or double) |
|   6   | `++x`, `--x`                 | none  | in/decrement  | operand type (int or double) |
|   5   | `e*e`, `e/e`                 | left  | mult, div     | operand type (int or double) |
|   4   | `e+e`, `e-e`                 | left  | add, sub      | operand type (int or double) |
|   3   | `e<e`, `e>e`, `e>=e`, `e<=e` | none  | comparison    | bool                         |
|   3   | `e==e`, `e!=e`               | none  | (in)equality  | bool                         |
|   2   | `e&&e`                       | left  | conjunction   | bool                         |
|   1   | `e\|\|e`                       | left  | disjunction   | bool                         |
|   0   | `x=e`                        | right | assignment    | type of both sides           |

**Typing rules**.

Integer, double, and boolean literals have their usual types.

Variables have the type declared in the nearest enclosing block.
A variable must be declared before it is used in an expression.

The arguments of a function call must have types corresponding to the argument types of the called function.
The number of arguments must be the same as in the function declaration (thus the C++ default argument rule is not applied).
Notice that only identifiers are used as functions.

Increments and decrements only apply to `int` and `double` _variables_.

The arithmetical and comparison operations apply to two operands of the same type, which is `int` or `double`.
(However, there â”€as everywhere!â”€ can be implicit coercions from `int` to `double`.)

Equality and inequality apply to two operands of the same type, which is `int`, `double`, or `bool`.

Conjunction and disjunction apply to operands of type `bool` only.

In assignments, both sides must have the same type, and this is then also the type of the assignment expression.
Notice that only variables are used as left hand sides.

## Literals

The language features integer literals, floating point literals, and the boolean literals, `true` and `false`.

## Identifiers

An identifier is a letter followed by a list of letters, digits, and underscores.

## Comments

There are three kinds of comments:
+ Block comment: anything between tokens `/*` and `*/`.
+ Line comment: anything from token `//` to the end of the line.
+ Preprocessor directive: anything from token `#` to the end of the line.

Block comments cannot be nested.

# The interpreter

The top-level interpreter is run by evaluating the expression `main()`.
The return value is ignored.

## Values

There are four types of values:
* integer values, e.g. `-47`,
* double values, e.g. `3.14159`,
* boolean values, `true` and `false`,
* a void value, which need never be shown.

The type `int` should be able to hold signed 32bit integers (Java: `int`), but may have larger precision, e.g. 64-bit or arbitrary precision (Haskell: `Integer`).
The type `double` should hold IEEE floating points of at least double precision (Java: `double`, Haskell: `Double`).

A value is the result of evaluating an expression in an environment.
Because of subtyping, integer values need sometimes be coerced to double values.

## Environments

The purpose of an environment is to bind variables to their values.
Our environment is structured into a stack of environment blocks.
Whenever we enter a new scope, we push a new block on the stack which we remove again when we leave the scope.

For illustration, consider the evaluation of these statements:
```cpp
int i = 2 ;      // create a new variable i in current scope with value 2
int j = 5 ;
{                // push a new environment block
  int i = 3 ;    // create a new variable i in this block with value 3
  i = i + j ;    // update this variable
  printInt (i) ; // print its value
}                // remove the top block
printInt (i) ;   // print the (unchanged) value 2 of i from the current scope
```

To implement evaluation of recursive functions, we need to save and restore whole environments.
For instance:
```cpp
int factorial (int n) {
  int r;
  if (n < 2) return 1;
  else {
    r = factorial (n - 1);
    return r * n;
  }
}
```
The evaluation of `factorial(2)` will bind `n` to `2`, and then call `factorial(1)`, which has to bind `n` to `1`.
It returns `1` which is bound to `r` but then we need the old value of `n` to correctly compute `r * n`.
Thus, we need a stack of environments to preserve the old bindings and access them again after we return from a function call.
However, this stack need not be represented explicitly, it can exist implicitly in the call stack of the host programming language.
E.g., both Haskell and Java support recursion and internally use a call stack to handle it correctly.

More precisely, the environments that map variables to values are _local environments_; they change frequently.

In contrast, there is also a fixed _global environment_ that maps function identifiers to their definitions (see below).
The global environment stays the same throughout the whole execution of a program.

## Programs

A program is a sequence of function definitions.
Each function has a parameter list and a body, which is a sequence of statements.

The interpreter runs a function only when encountering a function call expression (see below).
Then, it needs to know the function definition.
To this end, it has access to a _global environment_ that maps function identifiers to their definition, meaning their parameter list and their body.

## Statements

### Atomic statements

A declaration, e.g.
```cpp
int i ;
```
adds a variable to the current environment.
Its value is initialized if and only if the declaration includes an initializing expression, e.g.:
```cpp
int i = 9 ;
```
An expression statement, e.g.
```cpp
i++ ;
```
is evaluated, and its value is ignored.

A `return` statement is executed by evaluating its expression argument.
The value is returned to the caller of the function, and no more statements in the function body are executed.

### Blocks

A block of statements, e.g.
```cpp
{
  int i = 3 ;
  i++ ;
}
```
is interpreted in an environment where a new block is pushed on the environment stack at entrance, and popped at exit.

### While-loops

A `while` statement, e.g.
```cpp
while (i < 10) {
  i++ ;
  j-- ;
}
```
is interpreted so that the condition expression is first evaluated.
If the value is `true`, the body is interpreted in the resulting environment, and the `while` statement is executed again.
If the value is `false`, the body is not interpreted.

The body of a `while` statements needs to be interpreted in a fresh environment block even if it is just a single statement.
Example:
```cpp
while (i > 0) int i = 0;
```
The `i` declared by the body is not identical with the `i` in the condition.
Thus, if the condition `i > 0` holds initially, this should be an infinite loop.

### Conditionals

An `if-else` statement, e.g.
```cpp
if (x < 10) i++ ; else printInt(j) ;
```
is interpreted so that the condition expression is first evaluated.
If the value is `true`, the then-branch (statement before `else`) is interpreted.
If the value is `false`, the else-branch (statement after `else`) is interpreted.

Similar to `while` the branches of the `if` statement are fresh scopes
and need to evaluated with new environment blocks.
For example:
```cpp
int i = 0;
if (i > 0) i++; else int i = 1;
printInt(i);
```
This snippet should print `0` and not `1`, since the variable declared in the else-branch is a fresh `i`, not the `i` declared above.

## Expressions

The interpretation of an expression, also called evaluation, returns a value whose type is determined by the type of the expression.

### Literals

A literal, e.g.
* `123`
* `3.14`
* `true`

is not evaluated further but just converted to the corresponding value.

### Variables

A variable, e.g.
```cpp
x
```
is evaluated by looking up its value in the innermost environment block where it occurs.
Concretely, the environment blocks are searched for a binding for `x`, where the last added block is searched first.
Type-checking guarantees that the variable exists _somewhere_ in the environment.
If it has no value yet, the interpreter exits with the following error message:
```
uninitialized variable x
```
Note that this error should be raised by the following snippet
```cpp
int x = 1;
{
  int x;
  printInt(x);
}
```
since the initialized `x` is shadowed by an uninitialized `x`.
It should even be raised by
```cpp
int x = 1 + x;
```
since the variable `x` is already declared but still undefined at the point when the initializing expression `1 + x` will be evaluated.

### Function calls

The evaluation of a function call starts by evaluating the arguments, yielding a list of values and a new environment, the _caller environment_.
We then build a new environment, the _callee environment_, which consists of a single block mapping the function parameters to the argument values we just computed.

The statements in the function body are then executed in the _callee environment_, in the order defined by their textual order as altered by `while` loops and `if` conditions.

The function may return a value, which is obtained from the `return` statement.
After encountering a return, all the following statements in the function body should be ignored (not evaluated).
If the return type is `void`, no return statement is required.

After the function has returned, the _caller environment_ is restored.

For instance, the call
```cpp
foo (x+y, i<0, i++)
```
is interpreted by first evaluating its arguments from left to right.
The global environment is then queried to find out how the function is interpreted on the resulting values.

Say we have this definition of `foo` stored in the global environment,
```
int foo (double a, bool b, int c) {
  if (b) return c;
  return 0;
}
```
then we execute the statements `if (b) return c; return 0;` in the local environment that maps the parameters `a`, `b`, and `c` to the values of the call arguments `x+y`, `i<0` and `i++`.
This will return an `int` which is the value of the call `foo (x+y, i<0, i++)`.
Evaluation continues in the original environment, but not that evaluation of the third argument `i++` changed the value of `i` there.

Calls of the four built-in functions can be hard-coded as special cases in the expression evaluation code.

### Increment and decrement

A post-increment
```cpp
i++
```
has the same value as its body initially has (here `i`).
The value of the variable `i` is then incremented by `1`.
Post-decrement `i--` correspondingly  decrements `i` by `1`.
If `i` is of type `double`, `1.0` is used instead.

A pre-increment
```cpp
++i
```
has the same value as `i` plus `1`.
This incremented value replaces the old value of `i`.
The decrement and double variants are analogous.

### Arithmetic operations

The arithmetic operations
* addition `a + b`,
* subtraction `a - b`,
* multiplication `a * b`,
* and division `a / b`,

are interpreted by evaluating their operands from left to right.
The resulting values are then added, subtracted, etc., by using appropriate operations of the implementation language.

__Note:__
Division behaves differently for integer than for floating point arguments.
If both arguments are of type integer, then integer division is applied, which truncates the result.
If at least one of the arguments is a floating point value, then floating point division is applied, which returns a floating point.
To choose the correct operation, static typing information is needed (provided by the type checker).
Consider the following example:
```cpp
double divide (double x, double y) {
  return x / y;
}

int main() {
  printDouble (divide (5, 3));
}
```
Without type information, this program prints `1.0` (`printDouble(5/3)`).
But with the correct coercions introduced by the type checker, it prints `1.66667` (or similar).
The integer literals `5` and `3` need to be converted to floating point values when calling the function `divide`.

### Comparison operators

Comparisons and equality tests
* `a < b`
* `a > b`
* `a >= b`
* `a <= b`
* `a == b`
* `a != b`

are treated similarly to the arithmetic operations, using comparisons of the implementation language.
The returned value is a boolean.

Note that arithmetic and comparison operations require conversion of `int` values to `double` values if one argument is an `int` and the other a `double` value.

### Conjunction

```cpp
a && b
```
is evaluated __lazily__: first `a` is evaluated.
If the result is true, also `b` is evaluated, and the value of `b` is returned.
However, if `a` evaluates to false, then false is returned without evaluating `b`.

This makes a difference if `b` has a side effect, e.g. in `(i > 0) && (--i > 0)`.
Here, if `i â‰¤ 0`, the expression `--i > 0` is never evaluated, so `i` is not decremented.

### Disjunction

```cpp
a || b
```
is also evaluated lazily: first `a` is evaluated.
If the result is false, also `b` is evaluated, and the value of `b` is returned.
However, if `a` evaluates to true, then true is returned without evaluating `b`.

### Assignment

```cpp
x = a
```
is evaluated by first evaluating `a`.
The resulting value is returned, but also the environment is changed by assigning this value to the innermost occurrence of `x`.

# Lab format

## Solution templates

For Haskell and Java there are stubs that can be extended to the full solution.
If you are feeling very adventurous, you can try to solve the lab in Agda.
Just link one of these subdirectories to `src/`:

- [`src-agda/`](src-agda/): Agda template
- [`src-haskell/`](src-haskell/): Haskell template
- [`src-java/`](src/): Java template

These directores contain the grammar, stubs for type checker and interpreter, and suitable makefiles.
If you start from these stubs, you will likely match the requirements for the solution format as detailed in the following sections.

## Input and output

The interpreter must be a program called `lab2`, which is executed by the command
```console
$ lab2 <SourceFile>
```
and prints its output to the standard output.
The output at success must be just the output defined by the interpreter.

The output at failure is an `INTERPRETER ERROR`, a `TYPE ERROR` or, a `SYNTAX ERROR`, depending on the phase at which the error occurs.
These error messages should also give some useful explanation, which we leave to your imagination.

The input can be read not only from user typing on the terminal, but also from standard input redirected from a file or by `echo`.
For instance:
```console
$ ./lab2 fibonacci.cc < test-input
$ echo 20 | ./lab2 fibonacci.cc
$ ./lab2 fibonacci.cc <<< "20"
```

## Compiling the interpreter

The interpreter is submitted as archive of source files that can be compiled by typing `make`.

If you want to write the interpreter in another language, the procedure is the same.
However, you should make sure the interpreter can be compiled in a normal Unix environment by typing `make`.

# Test programs

Run the [testsuite](testsuite/) before submitting the lab.

There are pre-configured testsuite runner scripts in the repository root.
(These scripts only differ in the way they invoke the testsuite runner which is written in Haskell.)
- [`run-test-ghc.sh`](run-test-ghc.sh): Run testsuite with `runghc`.
- [`run-test-cabal.sh`](run-test-cabal.sh): Run testsuite with `cabal run`.
- [`run-test-stack.sh`](run-test-stack.sh): Run testsuite with `stack run`.

The scripts assume your sources in `src/` (see section [Submission](#submission)).


## Example of success

Source file `good.cc`:
```cpp
int main ()
{
  int i = readInt() ; // 5

  printInt(i) ;       // 5
  printInt(i++) ;     // 5
  printInt(i) ;       // 6
  printInt(++i) ;     // 7
  printInt(i) ;       // 7
}
```

Running the interpreter:
```console
$ echo 5 | ./lab2 good.cc
5
5
6
7
7
```

## Examples of failure

### Type error

Source file `bad.cc`:
```cpp
int f (double c)
{
  int n = 1 ;
  while (c) ++n ;
}
```

Running the type checker:
```console
$ lab2 bad.cc
TYPE ERROR

condition c in while: expected bool, found double
```


### Interpreter error

Source file `bad.cc`:
```cpp
int main ()
{
  int i ;

  printInt(i) ;
  printInt(i++) ;
  printInt(i) ;
  printInt(++i) ;
  printInt(i) ;
}
```

Running the interpreter:
```console
$ lab2 bad.cc
INTERPRETER ERROR

uninitialized variable i
```
Thus it is assumed that the type checker does not detect uninitialized variables.

# Success criteria

Your interpreter must pass the [test suite](testsuite/) and meet the specification in this document in all respects.
The test suite contains both good and bad programs.
The good programs must be executed correctly, whereas the bad ones must fail in appropriate ways in either the type checker or the interpreter.

The solution must be written in an easily readable and maintainable way.
In particular, tailoring it for the programs in the test suite is not maintainable!

# Submission

1. Do not submit your solution before it passes the [test suite](testsuite/) if you want proper grading.

2. Make sure your solution has the following structure:
   - Subdirectory `src/` contains the sources of your solution plus a `Makefile`.
   - After `make` is invoked in `src/`, there should be a runnable program `src/lab2`.
   - This program takes a filepath as command-line parameter and type-checks and interprets this file, printing type and interpreter errors and/or interpreter results to the standard output.

   See the example solution stubs `src-haskell/` and `src-java/`.
   If you solve this lab in Haskell or Java, you can symlink `src/` to one of `src-haskell/` or `src-java/` and work there.
   For another programming language, create `src/` and place a suitable `Makefile` there.

3. Make sure all your source files are pushed to your lab repository on `git.chalmers.se`.
   Do not submit generated files, only submit source files.

   Run the testsuite _on the server_ by pushing a `test` tag (e.g. `test0`, `test1` etc.).

4. Test that your submission builds in a fresh clone:
   ```console
   TMPDIR=`mktemp -d`
   git clone YOUR_LAB_REPO $TMPDIR
   cd $TMPDIR/src
   make
   ./lab2
   ```
    On Windows, the tools used here (`bash`, `mktemp`, `make`) are provided by both WSL and [MSYS2](https://www.msys2.org/).

5. Finalize your submission by adding a `submission` tag (e.g. `submission0`, `submission1`).
   The last submission before the deadline counts.

___________________________________________________________________________

_(C) 2022-23 Andreas Abel and the PLT Team.
All rights reserved._
