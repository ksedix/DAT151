Programming Language Technology (Chalmers DAT151 / GU DIT231)

# Lab 1: Parser for a fragment of C++

## Summary

The objective of this lab is to write an LR parser for a fragment of the C++ programming language.
The parser should return an abstract syntax tree at success, and report an error with a line number at failure.

Before the lab can be submitted, the parser has to pass the tests in the included test suite.

The recommended implementation of the parser is via a BNF grammar processed by the BNF Converter (BNFC) tool.
The approximate size of the parser source code should be 100 rules.

With BNFC, just the grammar (`.cf` file) has to be written and submitted.

## Method

Build the grammar gradually, so that you can parse the six test files in the given order: as your first goal, parse [the first file](testsuite/good/1-hello.cc); then the second, and so on.

When you have passed one level, just try to parse the next example with your current parser and examine the line at which it fails.
In this way, you will find out what new grammar rules you need.

After treating the six tests, run the [test suite](#lab-files) to make your parser perfect.

You can use any BNFC backend that produces an **LR parser**.
It need not be the language you use in later labs.
The LR backends of BNFC are:
- `--haskell`, using the [Happy](https://www.haskell.org/happy/) parser generator.
- `--java`, using [CUP](http://www2.cs.tum.edu/projects/cup/).
- `--c` and `--cpp`, using [Bison](https://www.gnu.org/software/bison/).
- `--ocaml`, using [`ocamlyacc`](https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html).
- `--ocaml-menhir`, using [Menhir](http://gallium.inria.fr/~fpottier/menhir/).

The `--java-antlr` backend generates an **LL parser** via [ANTLR](https://www.antlr.org/), so please do not use this backend for lab 1 as your grammar might then end up not being LR.

### Software requirements

Make sure your system can interpret shell scripts (e.g., [Bash](https://www.gnu.org/software/bash/)) and [make files](https://www.gnu.org/software/make/).

For building the parser with BNFC, an installation of a recent version (≥ 2.8.4) of [BNFC](http://bnfc.digitalgrammars.com/) is needed.
The recommended version is 2.9.5.

For automatic running of the testsuite, you'll need to generate and run Haskell code, requiring:
- A recent version (8.4 or higher) of [GHC](https://www.haskell.org/ghc/).
- A recent version (3.x) of the [Alex](https://www.haskell.org/alex/) lexer generator.
- A recent version (1.19.x or 1.20.x) of the [Happy](https://www.haskell.org/happy/) parser generator.

It is recommended to install GHC via [GHCup](https://www.haskell.org/ghcup/).
It is further recommended to use one of the build tools [Cabal](https://www.haskell.org/cabal/) or [Stack](https://docs.haskellstack.org/).
Those can be installed via GHCup as well: `ghcup install cabal` or `ghcup install stack` resp.
The build tools let you install Haskell packages and programs, e.g. `cabal install alex happy` or `stack install alex happy`.

In case you want to build your parser in Java, you need:
- a Java compiler (`javac`) and interpreter (`java`),
- the [CUP](http://www2.cs.tum.edu/projects/cup/) parser generator, and,
- for the lexer generation, either [JFlex](https://jflex.de/) or [JLex](https://www.cs.princeton.edu/~appel/modern/java/JLex/).

For building the parser in C or C++ there are `flex` and `bison`, often preinstalled with a C(++) compiler.

For OCaml, there are `ocamllex` and `ocamlyacc` or `menhir`.

See also the [Software](https://teach-plt.github.io/www/index.html#section9) section on the course homepage.

### Lab files

This repository contains the following files:

* [`CC.cf`](CC.cf): A stub LBNF file to be processed by BNFC, containing only the start symbol `Program`.
  Implement the grammar here.
  This is the only file you need to modify.

* [`testsuite/`](testsuite/):
  The testsuite for this lab: sample C++ files and a test runner written in Haskell.
  You need a working Haskell installation to run it, see above.

* Convenience shell scripts to run the test suite:
  - [`run-test-ghc.sh`](run-test-ghc.sh) (using `runghc`): needs `ghc`, `alex`, `happy` and `bnfc` in the `PATH`.
  - [`run-test-cabal.sh`](run-test-cabal.sh) (using `cabal`): needs `cabal` and `ghc` in the `PATH`, builds `alex`, `happy` and `bnfc` locally.
  - [`run-test-stack.sh`](run-test-stack.sh) (using `stack`): needs `stack` in the `PATH`, installs `ghc` locally, builds `alex`, `happy` and `bnfc` locally.

* [`.gitignore`](.gitignore):
  A whitelist for files that should be tracked in the repo.
  Feel free to change `.gitignore` so that `git` tracks all files you created or modified in the course of this lab.
  Do not add generated files, like the parser generated by BNFC!

  If you do not use BNFC to solve this lab, you probably have to change `.gitignore` substantially so that all your source files are tracked.

### Debugging conflicts

If you use Haskell, you have the advantage of readable **info files**, which tell you exactly where the (shift/reduce and reduce/reduce) conflicts are.
Assuming your grammar file is `CC.cf` and you have called `bnfc -dm CC.cf`, you can create an info file from the generated Happy file either by
```bash
make
```
(if the `Makefile` was created by BNFC ≥ 2.8.4) or manually via
```bash
happy -i CC/Par.y
```
The info file is now in `CC/Par.info`.
Search it for `(reduce` to get directly to the parser states with conflicts.

Moreover, you can produce a **debugging parser** by adding the `-d` flag to Happy.
Update your Makefile like this:
```bash
happy -gcaid CC/Par.y
```
And then run `make` again.
Running this parser shows a trace of the LR actions performed during parsing.

You can also get some debugging output when using the Java backend by calling CUPS with the `-dump_states` flag.
Edit your Makefile like this:
```makefile
CUPFLAGS = -nopositions -expect 100 -dump_states
```
And then recompile your parser with:
```bash
make -B CC/sym.class 2> parser.info
```
The `parser.info` file will contain some debugging information.
Unfortunately this format is harder to read than the info file generated by Happy (above).

Recent versions of `bison` (parser generator for C/C++) help with debugging conflicts by producing counterexamples, see the `counterexamples` or `cex` warning.

The OCaml parser generator `menhir` [advertises an option `--explain`](https://gallium.inria.fr/~fpottier/menhir/manual.html#sec39) to help with conflict resolution.

Note: While these different parser generators may have useful tools to explain conflicts, your grammar needs to work with a `happy`-generated parser in the end.

## Language specification

It is suitable to explain and advisable to implement the parser top-down, starting with the largest units and proceeding to smaller ones.

The specification differs in some places from the official C++ specification.

To help you get going, we have marked with a bold (**_n_**) those rules that are needed to parse the *n*th test file.

### Programs

A **program** is a sequence of definitions. (**1**)

A program may also contain comments and preprocessor directives,
which are just ignored by the parser (see below). (**1**)

If you are using BNFC, the category for programs should be named `Program`, to comply with the expectations of the [test suite](#lab-files).

### Definitions

1. A **function** definition has a type, a name, an argument list, and a body. (**1**)
   Example:
   ```cpp
   int foo(double x, int y)
   {
     return y + 9 ;
   }
   ```

2. Some statements can be used as top-level definitions:
   - `typedef` statements (**6**)
   - variable declarations and initializations

3. Finally, definitions for using qualified constants are allowed, (**2**) e.g.
   ```cpp
   using std::vector ;
   ```

### Argument lists, declarations, and function bodies

- An **argument list** is a comma-separated list of argument declarations.
  It is enclosed in parentheses: `(` and `)`. (**1**)

- An **argument declaration** always has a type.
  This type is optionally followed by an identifier or an identifier and an initialization. (**4**)
  The following are examples of argument declarations.
  ```cpp
  int
  int x
  int x = 5
  const int& x
  ```

  Notice that argument declarations with multiple variables (`int x, y`) are not included.
  Exception see below: a declaration that occurs as a statement can also have one or more variables.

- A **function body** is either a list of statements enclosed in curly brackets `{` and `}` (**1**), or an empty body consisting of a semicolon (**6**).
  Example:
  ```cpp
  int foo(double x, int y) ;
  ```

### Statements

1. Any **expression** followed by a semicolon `;` can be used as a statement. (**1**)

2. **Variable declarations** followed by a semicolon. (**2**)
   Variable declarations are similar to argument declarations in functions, except that they need at least one variable, and can have more than one variable.
   Examples:
   ```cpp
   int x;
   int x = 5, y, z = 3;
   const int x, y = 0;
   const int& x = y;
   ```

3. Statements **return**ing an expression (**1**), for example
   ```cpp
   return i + 9 ;
   ```

4. **While** loops, with an expression in parentheses followed by a statement. (**3**)
   For example:
   ```cpp
   while (i < 10) ++i ;
   ```

5. **Do-while** loops, with an expression in parentheses after the loop body. (**6**)
   For example:
   ```cpp
   do ++i ; while (i < 10) ;
   ```

6. **For** loops, with a declaration and two expressions in parentheses followed by a statement. (**6**)
   For example:
   ```cpp
   for (int i = 0 ; i != 10 ; ++i) k = k + i ;
   ```

   We do not require that any of the fields in parentheses may be empty.

7. **Conditionals**: `if` with an expression in parentheses followed by a statement and optionally by `else` and a statement. (**3**)
   Examples:
   ```cpp
   if (x > 0) return x ;

   if (x > 0) return x ; else return y ;
   ```

8. **Blocks**: any list of statement (including empty list) between curly brackets. (**3**)
   For instance,
   ```cpp
   {
     int i = 2 ;
     {
     }
     i++ ;
   }
   ```

9. **Type definitions**: a type and a name for it. (**3**)
   Examples:
   ```cpp
   typedef vector_string Text ;
   typedef const int my_const_int ;
   ```

Note: semicolons are not used after curly brackets, but they are obligatory in all statements and definitions not ending with curly brackets.

### Expressions

The following table gives the expressions, their precedence levels, and their associativity.
The associativity of operators is given as "left" or "right".
(C++ operators do not use "non"-associativity.)
For binary operators, in general any of these associativities is meaningful.
Prefix operators cannot be left associative, and postfix operators cannot be right associative.
The argument in an array index, the arguments in a function call, and the middle expression in the conditional can be expressions of any level, since they are bracketed.
Otherwise, some subexpressions have to be one precedence level above of the main expression to implement the required the associativity.

**Note**.
The precedences are not exactly the same as in the [C++ standard](https://en.cppreference.com/w/cpp/language/operator_precedence), but very similar.

| level | expression forms             | assoc | explanation                         | test    |
|------:|:-----------------------------|:-----:|:------------------------------------|:-------:|
|  15   | literal                      | ---   | atomic expressions                  | (**1**) |
|  15   | `x`, `x::x`, `x::x::x`, ...  | ---   | qualified constants                 | (**1**) |
|  14   | `e[e]`                       | left  | indexing                            | (**3**) |
|  14   | `e(e,...,e)`                 | left  | function call                       | (**3**) |
|  14   | `e.e`, `e->e`                | left  | structure projection                | (**3**) |
|  14   | `e++`, `e--`                 | left  | in/decrement                        | ---     |
|  13   | `++e`, `--e`, `*e`, `!e`     | right | in/decrement, dereference, negation | (**6**) |
|  12   | `e*e`, `e/e`, `e%e`          | left  | multiplication, division, remainder | (**3**) |
|  11   | `e+e`, `e-e`                 | left  | addition, subtraction               | (**3**) |
|  10   | `e<<e`, `e>>e`               | left  | left and right shift                | (**1**) |
|   9   | `e<e`, `e>e`, `e>=e`, `e<=e` | left  | comparison                          | (**6**) |
|   8   | `e==e`, `e!=e`               | left  | (in)equality                        | (**3**) |
|   4   | `e&&e`                       | left  | conjunction                         | (**6**) |
|   3   | `e\|\|e`                     | left  | disjunction                         | (**6**) |
|   2   | `e=e`, `e+=e`, `e-=e`        | right | assignment                          | (**3**) |
|   2   | `e ? e : e`                  | right | conditional                         | (**3**) |
|   1   | `throw e`                    | right | exception                           | (**4**) |

Note that this grammar includes expressions that are meaningless.
For instance, it permits increment, decrement, and assignment on any expression, but this makes only sense on so-called _l-values_ such as variables and array positions.
Meaningless expressions can be ruled out in later compilation phases, e.g., in the type-checking phase, and at that point, good error messages can be given (rather than just _parse error_).

_Indexing_ `_[e]` is treated as a postfix operator; the expression `e` is bracketed and can be of any level.
Indexing is associative, i.e., `e[e1][e2]` is allowed and means `(e[e1])[e2]`.
It is necessarily _left_ associative, since the other bracketing, `e([e1][e2])` would be meaningless.
_Function call_ is similar to indexing.

The _conditional_ `_?e:_` is treated as a binary operator with a fixed "then"-expression `e`.
Right associativity for the conditional has the usual meaning:
  `c1 ? t1 : c2 ? t2 : e2`
is parsed as
  `c1 ? t1 : (c2 ? t2 : e2)`
and not as
  `(c1 ? t1 : c2) ? t2 : e2`.
Note also that `?` and `:` act like left and right parenthesis.
Thus, `e` can be of any level and, for instance,
  `c1 ? c2 ? t1 : e1 : e2`,
while being confusing, is unambiguous, meaning
  `c1 ? (c2 ? t1 : e1) : e2`.

### Qualified constants

**Qualified constants** (**1**) are identifiers separated by `::` such as `std::cout`.
Qualified constants can simply implemented as nonempty lists separated by `::`.
The elements of the list are identifiers.
Single identifier expressions come out as a special case of these lists.

Note: in C++, identifiers in qualified constants can be followed by template instantiations of the form
```cpp
ident < typelist >
```
where a typelist is a comma-separated list of types.
Thus, possible qualified constants in C++ include
```cpp
std::vector<t>::const_iterator
std::map<int,vector<string>>
```
However, it is not trivial to integrate this into our LR grammar, because the parser can confuse the initial part `std::vector<t` with the expression `e1<e2` where `e1` and `e2` are the (qualified) constants `std::vector` and `t`.
Therefore, we leave template instantiations out of this assignment.

### Types

1. Built-in types: `int` (**1**), `bool`, `char`, `double`, `void`.

2. Qualified constants, including plain identifiers (**1**), e.g. `string`.

3. A type preceded by qualifier `const` (**4**), e.g. `const int`.

4. Type references. (**4**)
   The reference operator `&` is a postfix-operator forming types from types, e.g. `int &`.

   Note that from C++ 11, double references like `int &&` are also allowed.
   It is sufficient to support them with spaces between the `&`s, e.g. `int & &`.
   Otherwise, `x && y;` would be ambiguous: it could be the declaration `x & & y;` or a conjunction expression as statement.

   It is sufficient to support references and double references in the grammar.
   However, it is also fine to allow arbitrary stacking of the reference operator, as for instance in `char & & & &`.

### Literals

1. Non-negative **integer** literals, e.g, `0`, `00`, `20`, `151`. (**1**)
2. Non-negative **floating point** literals, e.g., `01.10`, `3.14`, `10.0e10`, `0.00e-00`, `1.1e-80`. (**3**)
3. Single-quoted **character** literals, e.g. `'0'`, `'a'`, `'"'`, `'\''`, `'\n'`. (**6**)
4. Double-quoted **string** literals (**1**), e.g.:
   - `"abc"`,
   - `"This,\n is \"insane\"!"`,
   - `"LaTeX's \"\\newcommand\""`.

   A string literal may consist of many double-quoted character sequences which will be concatenated.
   The parts can be divided over lines (**3**).
   E.g.,
   ```cpp
   "hello " "my little "
   "world"
   ```
   is an alternative way to say "hello my little world".

### Identifiers

An **identifier** is a letter followed by a list of letters, digits, and underscores. (**1**)

### Comments

There are three kinds of comments: (**1**)
1. Block comment: anything between tokens `/*` and `*/`.
2. Line comment: anything from token `//` to the end of the line.
3. Preprocessor directive: anything from token `#` to the end of the line.

Block comments cannot be nested.

## Test programs

Build the grammar gradually so that you can parse the following test files in the given order.

These programs are taken from the web page of the book _Accelerated C++_ (A. Koenig & B. Moo, Addison-Wesley, 2000).
To comply to our grammar, we have removed template instantiations.

1. [First](testsuite/good/1-hello.cc): Print "Hello, world!".
2. [Second](testsuite/good/2-greet.cc): Ask the user's name and say hello to him/her.
3. [Third](testsuite/good/3-med.cc): Compute the grade of a student.
4. [Fourth](testsuite/good/4-grade.cc): A smarter way to compute the grade.
5. [Fifth](testsuite/good/5-palin.cc): Test if a string is a palindrome.
6. [Sixth](testsuite/good/6-grammar.cc): Randomly generate English sentences.

Finally, run your parser through the [test suite](#lab-files).

## Success criteria

Your grammar must pass the [test suite](#) and meet the specification in this document in all respects.
The test suite contains the example programs, as well as a number of programs which your parser must reject.

Note that passing the test suite is a necessary condition to pass the lab, but _not a sufficient_ one.
Your grammar must encompass _all_ programs that match the specification in this document, _and just those_.
We will test your grammar against additional examples that are not contained in the public test suite.

Your grammar may **not** have any **reduce/reduce conflicts**.
If your grammar has **shift/reduce conflicts** but the parser works, you may leave these conflict in the grammar.
However, you need to **document** each of these conflicts and explain why it arises and why it is harmless.
The documentation may be placed in suitable comments in the grammar file.

For instance, you may get one shift/reduce conflict from the "dangling `else`".
It is fine to leave this conflict in as long as you explain why the parser still behaves correctly (i.e. why _shift_ is always the correct action in the situations where a _reduce_ would
also be possible).

The solution must be written in an easily readable and maintainable way.
In particular, tailoring it for the programs in the test suite is not maintainable!

## Submission

Do not forget to push your implemented grammar `CC.cf` to this repository.

When you are finished, follow [our guide](https://chalmers.instructure.com/courses/26247/pages/lab-infrastructure-on-chalmers-gitlab#submitting-a-lab) for creating a submission:
* Create a tag `submission0` (for the commit you wish to submit).
  For re-submissions, use `submission1`, `submission2`, etc.
* If you create the tag in your local repository, remember to push with `--follow-tags` to push the submission tag.
* We will post our grading feedback as a pull request in your project.
  You will receive an email notification, so make sure you have configured an email in https://git.chalmers.se that you poll regularly.

## Appendix: C++ features

Assuming you know some C but not C++, here is a summary of the extra features of C++ involved in this lab.

* Qualified names: `s::n`, where `s` is a name space or a class.

* `using` directives: license to use an unqualified name from a name space.

* IO streams: `cout` for output, `cin` for input.
  Output is produced by the left shift operator, input is read by the right shift.
  Example from [the second program](testsuite/good/2-greet.cc):
  ```cpp
  // read the name
  std::string name;     // define `name'
  std::cin >> name;     // read into `name'

  // write a greeting
  std::cout << "Hello, " << name  << "!" << std::endl;
  ```

* Arguments passed by reference (`&`), with the possibility of forbidding modification (`const`), e.g. (from [the sixth program](testsuite/good/6-grammar.cc))
  ```cpp
  gen_aux(const Grammar& g, const string& word, vector_string& retc)
  ```

___________________________________________________________________________

_(C) 2022-23 Andreas Abel and the PLT Team.
All rights reserved._
